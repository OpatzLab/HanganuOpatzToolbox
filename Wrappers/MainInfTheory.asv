
% This example script computes some information theory parameters based on
% spike trains. Among other things, It can be used to assess the "complexity" of a spike train
% (its entropy) or the communication (mutual information) between different
% spike trains
% In this example script, two spike matrices from two different brain areas
% are loaded, they are summed into a single vector, they are downsampled,
% and then their characteristics are computed.


%% load experiment info and set a few variables for analysis

clear
% load experiments and generic stuff
experiments = get_experiment_steven;
repeatCalc = 1;
save_data = 1;

resultsMUA = 'your_folder_here';
output_folder_SM = 'your_folder_here';
output_folder = 'your_folder_here';

%% compute all sort of stuff, on an experiment by experiment basis

for exp_idx = 1 : size(experiments, 2)
    % take out exp with diff length of rec in diff channels
    if experiment.to_load > 0
        disp(['working on animal number ' num2str(exp_idx)])
        % select experiment
        experiment = experiments(exp_idx);
        spikesPFC = []; spikesHP = [];
        if ~ isnan(str2num(experiment.PL))
            % load spike matrix from 1st brain area & make single spike vector
            spikesPFC = getSpikeMatrix(experiment.animal_ID, resultsMUA, ...
                output_folder_SM, save_data, repeatCalc, 'PFC');
            if size(spikesPFC, 1) > 1
                spikesPFC = sum(spikesPFC, 1);
            end
        end
        if isnumeric(experiment.reversal)
            % create HP MUA spike matrix & make single spike vector
            spikesHP = getSpikeMatrix(experiment.animal_ID, resultsMUA, ...
                output_folder_SM, save_data, repeatCalc, 'HP');
            if size(spikesHP, 1) > 1
                spikesHP = sum(spikesHP, 1);
            end
        end
        if ~ isempty(spikesHP) && ~ isempty(spikesPFC)
            % extend the shortest spike vector
            if length(spikesPFC) ~= length(spikesHP)
                switch length(spikesPFC) > length(spikesHP)
                    case 1
                        spikesHP(end + 1: length(spikesPFC)) = 0;
                    case 0
                        spikesPFC(end + 1: length(spikesHP)) = 0;
                end
            end
        end
        % downsample both vectors to 50ms bins
        num_bins = floor(length(spikesPFC) / 50);
        spikesPFC = sum(reshape(spikesPFC(1 : 50*num_bins), 50, []));
        num_bins = floor(length(spikesHP) / 50);
        spikesHP = sum(reshape(spikesHP(1 : 50*num_bins), 50, []));
        % compute entropy of the two spike vectors
        H_PFC = entropy(spikesPFC);
        H_HP = entropy(spikesHP);
        if ~ isempty(spikesHP) && ~ isempty(spikesPFC)
            % compute conditional entropy
            H_PFC_HP = condEntropy(spikesPFC, spikesHP);
            H_HP_PFC = condEntropy(spikesHP, spikesPFC);
            % compute mutual information
            I_HP_PFC = mutInfo(spikesPFC, spikesHP);
            % compute normalized mutual information I_n(x,y)
            nI_HP_PFC = nmi(spikesPFC, spikesHP);
        else
            H_PFC_HP = NaN;
            H_HP_PFC = NaN;
            I_HP_PFC = NaN;
            nI_HP_PFC = NaN;
        end
        % put everything into a structure
        InfTheory.PFC_Ent = H_PFC;
        InfTheory.HP_Ent = H_HP;
        InfTheory.PFC_HP_Cond_Ent = H_PFC_HP;
        InfTheory.HP_PFC_Cond_Ent = H_HP_PFC;
        InfTheory.Mut_Info = I_HP_PFC;
        InfTheory.norm_Mut_Info = nI_HP_PFC;
        % save everything
        save([output_folder, experiment.animal_ID], 'InfTheory')
        clear spikesHP spikesPFC
    end
end