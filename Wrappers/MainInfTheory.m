
% This example script computes some information theory parameters based on
% spike trains. Among other things, it can be used to assess the 
% "complexity" of a spike train (its entropy) or the communication 
% (mutual information) between different spike trains.
% In this example script, two spike matrices from two different brain areas
% are loaded, they are summed into a single vector, they are downsampled,
% and then their characteristics are computed.


%% load experiment info and set a few variables for analysis

clear
% load experiments and generic stuff
experiments = get_experiment_redux;
repeatCalc = 1;
save_data = 1;

resultsMUA = 'your_folder_here';
output_folder_SM = 'your_folder_here';
output_folder = 'your_folder_here';

% length of the bin to which spike will be downsampled
len_bin = 50; % in ms

%% compute all sort of stuff, on an experiment by experiment basis

for exp_idx = 1 : size(experiments, 2)
    disp(['working on animal number ' num2str(exp_idx)])
    % select experiment
    experiment = experiments(exp_idx);
    % use your function to load your 1st spike matrix 
    spikes_matrix1 = 'use your function here';
    if size(spikes_matrix1, 1) > 1
        spikes_matrix1 = sum(spikes_matrix1, 1);
    end
    % create HP MUA spike matrix & make single spike vector
    spikes_matrix2 = 'use your function here';
    if size(spikes_matrix2, 1) > 1
        spikes_matrix2 = sum(spikes_matrix2, 1);
    end
    if ~ isempty(spikes_matrix2) && ~ isempty(spikes_matrix1)
        % extend the shortest spike vector (if the spike matrices are
        % generated by klusta, this does not distor their alignment)
        if length(spikes_matrix1) ~= length(spikes_matrix2)
            switch length(spikes_matrix1) > length(spikes_matrix2)
                case 1
                    spikes_matrix2(end + 1: length(spikes_matrix1)) = 0;
                case 0
                    spikes_matrix1(end + 1: length(spikes_matrix2)) = 0;
            end
        end
    end
    % downsample both vectors to 50ms bins
    num_bins = floor(length(spikes_matrix1) / len_bin);
    spikes_matrix1 = sum(reshape(spikes_matrix1(1 : len_bin*num_bins), len_bin, []));
    num_bins = floor(length(spikes_matrix2) / len_bin);
    spikes_matrix2 = sum(reshape(spikes_matrix2(1 : len_bin*num_bins), len_bin, []));
    % compute entropy of the two spike vectors
    H_PFC = entropy(spikes_matrix1);
    H_HP = entropy(spikes_matrix2);
    if ~ isempty(spikes_matrix2) && ~ isempty(spikes_matrix1)
        % compute conditional entropy
        H_PFC_HP = condEntropy(spikes_matrix1, spikes_matrix2);
        H_HP_PFC = condEntropy(spikes_matrix2, spikes_matrix1);
        % compute mutual information
        I_HP_PFC = mutInfo(spikes_matrix1, spikes_matrix2);
        % compute normalized mutual information I_n(x,y)
        nI_HP_PFC = nmi(spikes_matrix1, spikes_matrix2);
    else
        H_PFC_HP = NaN;
        H_HP_PFC = NaN;
        I_HP_PFC = NaN;
        nI_HP_PFC = NaN;
    end
    % put everything into a structure
    InfTheory.PFC_Ent = H_PFC;
    InfTheory.HP_Ent = H_HP;
    InfTheory.PFC_HP_Cond_Ent = H_PFC_HP;
    InfTheory.HP_PFC_Cond_Ent = H_HP_PFC;
    InfTheory.Mut_Info = I_HP_PFC;
    InfTheory.norm_Mut_Info = nI_HP_PFC;
    % save everything
    save([output_folder, experiment.animal_ID], 'InfTheory')
    clear spikesHP spikesPFC
end